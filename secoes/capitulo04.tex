\chapter{Implementação e Validação} %não sei como chamar este capitulo
\label{chap:cap4}

Este capítulo apresenta uma ferramenta com objetivo de tornar transparente a abordagem de tradução e a verificação para os usuários do RoboMind. Na Seção \ref{sec:tool} é apresentada a ferramenta proposta que é responsável por integrar a abordagem de tradução, apresentada no Capítulo \ref{chap:cap3}, com o verificador de modelos FDR. Na Seção~\ref{sec:caso} é apresentado um estudo de caso através de um exemplo de problema real utilizando o protótipo proposto, objetivando sua validação.

\section{Ferramenta}
\label{sec:tool}
Propomos um protótipo desenvolvido na linguagem de programação Java\footnote[7]{https://java.com/download}. Este protótipo provê as principais funcionalidades para a verificação automática dos programas ROBO. Este protótipo foi proposto conforme o Diagrama de Classes disposto na Figura~\ref{fig:diagrama}. A interface (\texttt{Checker}) possui três métodos: \texttt{translateRobo2CSP}, que recebe como entrada uma \textit{string} do programa escrito na linguagem ROBO; \texttt{translateMap2CSP} que recebe uma \textit{string} com a representação textual de um mapa do ambiente RoboMind; e \texttt{verifyAssertion} que recebe como entrada o programa e o mapa na notação CSP. A classe \texttt{RobotChecker} implementa a interface \texttt{Checker}. Essa classe possui alguns atributos que são responsáveis por armazenar informações importantes da tradução e da verificação. O atributo \texttt{programCSP} é utilizado para armazenar uma \textit{string} com a especificação formal CSP traduzido de ROBO através do retorno do método \texttt{translateRobo2CSP} utilizando os serviços providos pela classe \texttt{Spoofax}. O atributo \texttt{mapCSP} armazena o texto com a representação CSP do mapa do RoboMind após a tradução por meio do método \texttt{translateMap2CSP}. Os atributos \texttt{result} e \texttt{traces} são resultados da verificação automática por meio dos serviços fornecidos pela classe \texttt{FDR} que ocorre no método \texttt{verifyAssertion} utilizando como entrada as representações CSP do programa e do mapa gerados pelos métodos anteriores. Para tornar transparente a tradução com Spoofax e a verificação com FDR para o usuário, desenvolvemos uma camada de apresentação através da classe \texttt{GUI}. Tal classe, possui alguns elementos essenciais. O atributo \texttt{btnProgram} representa um botão com a finalidade de buscar o programa ROBO fornecido pelo usuário. O atributo \texttt{btnMap} representa um botão para o usuário fornecer os mapas do RoboMind como entrada. O atributo \texttt{btnVerify} tem o intuito de iniciar o processo de tradução e posteriormente a verificação por meio da chamada do método \texttt{translator} da classe \texttt{Controller} que recebe como entrada o programa e mapas do usuário. Os atributos \texttt{txtResult} e \texttt{txtTraces} são utilizados para exibir na tela da ferramenta o resultado da verificação e os traces gerados pela verificação, respectivamente.

Listamos as principais funcionalidades do protótipo implementado:

\begin{itemize}
    \item Tradução de ROBO para CSP: recebe um programa ROBO como entrada e através da API do Spoofax é realizada a tradução usando o compilador desenvolvido por esta pesquisa; e como saída é gerado a especificação do programa em notação CSP.
    \item Tradução de mapa: recebe um mapa do ambiente RoboMind como entrada e realiza a tradução automática; e como saída é gerado a especificação formal em CSP do mapa.
    \item Verificação das propriedades no FDR: recebe como entrada o mapa e o programa escritos em CSP, resultado da tradução automatizada; e como saída gera os resultados das verificações e os \textit{traces} resultantes, se houver.
\end{itemize}

\begin{figure}[!h]
\centering
\caption{Diagrama de Classes do protótipo}
\includegraphics[height=8cm]{figuras/class_diagram.png}
\fonte{O autor}
\label{fig:diagrama}
\end{figure}

A Figura~\ref{fig:guiprot} mostra a Interface Gráfica do Usuário (\textit{Graphical User Interface} - GUI) do protótipo. Essa ferramenta é a implementação do diagrama mostrado anteriormente. A interface conta com três botões: ``Mapa'' onde o usuário escolhe um ou mais mapas do RoboMind, onde são listados abaixo; ``Programa'' onde o usuário seleciona o arquivo do programa ROBO, o nome do arquivo é posto abaixo dos botões; e no meio da tela está o botão ``Verificar`` que executa a tradução e em seguida a verificação. No lado direito da figura são listados os \textit{traces} gerados pela verificação. Na parte inferior da figura tem um \textit{console} para que o usuário tenha um \textit{feedback} do resultado da verificação automática.

\begin{figure}[!h]
\centering
\caption{Interface gráfica da ferramenta}
\includegraphics[height=8cm]{figuras/prototipo2.png}
\fonte{O autor}
\label{fig:guiprot}
\end{figure}

\section{Estudo de caso}
\label{sec:caso}

No Capítulo \ref{chap:cap3} foi apresentado um exemplo (Contando Caixas) adaptado de \cite{furb} que foi utilizado para exemplificar o processo de definição sintática e transformação. Para o nosso estudo de caso, vamos utilizar a versão completa desse exemplo.

O problema consiste em um mapa de 6 colunas e 3 linhas que possui caixas distribuídas aleatoriamente na primeira e última linha. Neste mapa o robô inicia na primeira coluna da segunda linha e tem o objetivo de andar até a última coluna e parar. Após parar o robô, o programa mostra seis valores inteiros através do comando \texttt{show}. Os dois primeiros valores representam a quantidade de caixas encontradas na primeira e últimas linhas, respectivamente. O terceiro valor mostrado indica quais das linhas possui mais caixas:  o valor 1 indica que a primeira linha possui mais caixas, o valor 2 que a última linha tem mais caixas, e o valor 3  que as linhas possuem a mesma quantidade de caixas. O quarto valor exibido é a diferença de caixas entre as duas linhas. O quinto valor indica em qual linha apareceu a primeira caixa: 1 se apareceu na primeira linha, 2 se apareceu na última linha; e 3 se apareceu em ambas as linhas. O sexto e último valor indica em qual linha apareceu a última caixa: 1 se apareceu na primeira linha, 2 se apareceu na última linha; e 3 se apareceu em ambas as linhas. Neste estudo de caso o programa ROBO foi verificado considerando os mapas apresentados na Figura \ref{fig:problem}. Nesta figura, para cada um dos mapas é mostrado no lado direito do mapa os valores que são mostrados pelo programa.

\begin{figure}[h]
\centering
\caption{Mapas e saídas esperadas do problema ``Contando Caixas"}
\includegraphics[height=10cm]{figuras/map_caso.png}
\fonte{\cite{furb}}
\label{fig:problem}
\end{figure}

Para esses mapas desenvolvemos um programa ROBO. O Código~\ref{fig:solution} apresenta a solução proposta para esse problema. Nas linhas de 1 a 12 estão declaradas as variáveis. As variáveis \texttt{countFirstLine} e \texttt{countLastLine} armazenam a quantidade de caixas na primeira e última linha, nesta ordem. As variáveis \texttt{findFirstBoxLeft} e \texttt{findFirstBoxRight} apontam quando a primeira caixa é encontrada na primeira e última linha, respectivamente. As variáveis \texttt{firstBoxLeft} e \texttt{firstBoxRight} são utilizadas para armazenar a linha que aparece a primeira caixa. Já as variáveis \texttt{lastBoxLeft} e \texttt{lastBoxRight} armazenam a linha (primeira ou última) que aparece a última caixa. A quantidade de vezes que a instrução \texttt{forward} é executada é armazenada na variável \texttt{countForward}. Foram implementados alguns procedimentos para cada valor. O procedimento \texttt{countBoxes} (linhas 14 a 38) conta a quantidade de caixas à direita ou esquerda do robô dependendo do valor do parâmetro \texttt{side}: valor 1 para contar à esquerda (primeira linha) e qualquer valor diferente de 1 para contar à direita (última linha). Para \texttt{side} igual a 1, esse procedimento incrementa em 1 a variável \texttt{countFirstLine} se à esquerda do robô tem obstáculo, isto é, se possui uma caixa. Em seguida, verifica se a variável \texttt{findFirstBoxLeft} é igual a 0, o que significa que ainda não encontrou a primeira caixa, e atualiza o valor de \texttt{firstBoxLeft} para a quantidade de comandos \texttt{forward} executados (\texttt{countForward}), assim, atualizando \texttt{findFirstBoxLeft} para o valor 1, indicando que a caixa da primeira linha foi encontrada. Essa explicação é análoga para \texttt{side} diferente de 1, o que significa que a verificação ocorre na última linha (à direita do robô). O procedimento \texttt{showsMoreBoxes} (linha 40 a 51) exibe no \textit{console} do RoboMind a linha com mais caixas e a diferença de caixas entre a primeira e última linha. O procedimento \texttt{getBoxFirstLine} (linhas 53 a 61) exibe qual das linhas há uma ocorrência da primeira caixa. Já o procedimento \texttt{getboxLastLine} (linhas 63 a 71) exibe o valor correspondente à linha no qual a última caixa aparece. As instruções que iniciam o programa estão dispostas nas linhas 73 a 88. O primeiro comando é \texttt{right}, que altera a orientação do robô para movimentar na direção correta. O comando seguinte é \texttt{repeatWhile} que executa os comandos internos do comando até que não haja uma parede na frente do robô. No escopo desse laço, há duas chamadas para o procedimento \texttt{countBoxes}, os valores 1 e 2 são passados no parâmetro, para verificar à esquerda e à direita do robô, respectivamente. A próxima instrução é um \texttt{forward} para movimentar o robô uma célula à frente e em seguida incrementar o valor de \texttt{countForward} em 1. Ao sair do laço, o programa executa novamente o procedimento \texttt{countBoxes} para verificar na célula onde o robô parou, se há ocorrência de caixas na primeira e última linha. As próximas instruções são para exibir as saídas do programa no \textit{console} do RoboMind: \texttt{show(countFirstLine)} e \texttt{show(countLastLine)} exibem o primeiro e segundo valor; a chamada do procedimento \texttt{showsMoreBoxes} exibe o terceiro e quarto valor; a chamada do procedimento \texttt{getBoxFirstLine} exibe o quinto valor; e \texttt{getBoxLastLine} exibe o sexto valor.

\lstinputlisting[caption=Solução proposta em ROBO para o problema Contando Caixas, label=fig:solution,numbersep=8pt]{codes/solution_completa.rob}
\fonte{O autor}


%Para validar a efetividade do compilador integrado ao FDR, foi necessário verificar as saídas geradas pelo protótipo e executar os \textit{traces} no ambiente RoboMind, obtidos através do resultado da verificação da propriedade: \texttt{assert PROGRAM :[deadlock free [F]]}.

Para validarmos a ferramenta implementada, utilizamos como entrada os três mapas apresentados na Figura~\ref{fig:problem} e o programa mostrado no Código~\ref{fig:solution}. Expomos em tabelas as entradas e saídas para cada dos métodos da classe \texttt{RobotChecker}. Na Tabela~\ref{table:map1}, \texttt{program.robo} é a entrada para o método \texttt{translateRobo2CSP} e como saída é gerado a especificação formal em CSP (\texttt{program.csp}). No método \texttt{translateMap2CSP}, map1.map é o arquivo de entrada e map1.csp é a saída gerada pela tradução do mapa para notação CSP. Em \texttt{verifyAssertion}, a notação CSP do mapa e do programa (\texttt{program.csp} e \texttt{map1.csp}) são entradas para a verificação. Além dessas entradas, também é incluído \texttt{test1\_program\_map1.csp}, responsável por incluir os arquivos CSP utilizados na verificação, este é gerado durante a execução do método. Na Figura~\ref{fig:test} é mostrado um exemplo. As linhas 1 a 3 incluem as especificações do modelo, do mapa e do programa. A linha 5 está disposto a propriedade a ser verificada por FDR (\texttt{assert PROGRAM :[deadlock free [F]]}). As saídas do método \texttt{verifyAssertion} são o resultado da verificação da propriedade (\texttt{result1}) e os traces gerados (\texttt{traces1}). As explicações mencionadas são análogas para a Tabela~\ref{table:map2} e para a Tabela \ref{table:map3}.

\begin{figure}[!h]
\centering
\caption{Exemplo de entrada para a verificação no FDR}
\lstinputlisting[nolol]{codes/test.csp}
\fonte{O autor}
\label{fig:test}
\end{figure}

\begin{table}[h]
\caption{Entradas e saídas para o mapa 1}
\resizebox{\textwidth}{!}{%
\begin{tabular}{*{14}{|c}|}
\hline
\multicolumn{3}{|c|}{\textbf{Map 1}} \\ \hline
\textbf{method} & \textbf{input} & \textbf{output} \\ \hline
translateRobo2CSP & program.robo & program.csp \\ \hline
translateMap2CSP & map1.map & map1.csp \\ \hline
verifyAssertion & program.csp, map1.csp, test1\_program\_map1.csp & result1, traces1 \\ \hline
\end{tabular}%
}
\label{table:map1}
\fonte{O autor}
\end{table}

\begin{table}[h]
\caption{Entradas e saídas para o mapa 2}
\resizebox{\textwidth}{!}{%
\begin{tabular}{*{14}{|c}|}
\hline
\multicolumn{3}{|c|}{\textbf{Map 2}} \\ \hline
\textbf{method} & \textbf{input} & \textbf{output} \\ \hline
translateRobo2CSP & program.robo & program.csp \\ \hline
translateMap2CSP & map2.map & map2.csp \\ \hline
verifyAssertion & program.csp, map2.csp, test2\_program\_map2.csp & result2, traces2 \\ \hline
\end{tabular}%
}
\label{table:map2}
\fonte{O autor}
\end{table}

\begin{table}[h]
\caption{Entradas e saídas para o mapa 3}
\resizebox{\textwidth}{!}{%
\begin{tabular}{*{14}{|c}|}
\hline
\multicolumn{3}{|c|}{\textbf{Map 3}} \\ \hline
\textbf{method} & \textbf{input} & \textbf{output} \\ \hline
translateRobo2CSP & program.robo & program.csp \\ \hline
translateMap2CSP & map3.map & map3.csp \\ \hline
verifyAssertion & program.csp, map3.csp, test3\_program\_map3.csp & result3, traces3 \\ \hline
\end{tabular}%
}
\fonte{O autor}
\label{table:map3}
\end{table}

Utilizando o protótipo apresentado na Figura~\ref{fig:guiprot}, selecionamos os três mapas apresentados na Figura~\ref{fig:problem} e o programa apresentado no Código~\ref{fig:solution} como entrada para a ferramenta. Executamos a verificação e obtivemos os resultados apresentados na Tabela~\ref{table:results}. Para os três mapas o resultado da propriedade \texttt{assert PROGRAM :[deadlock free [F]]} falhou, o que significa que para cada um dos mapas o programa ROBO não possui \textit{deadlock}, portanto, o programa termina sua execução. O contraexemplo gerado (\textit{traces}) para os três mapas comunicam os eventos \texttt{right} e \texttt{forward}, pois a primeira instrução do programa é virar a direita seguindo de um laço que avança uma célula enquanto não há uma parede na frente do robô. Como são cinco células até que haja uma parede na frente, o programa executa cinco vezes o comando \texttt{forward}. Os eventos que diferem entre os mapas são os eventos (\texttt{show}) com os valores mostrados no \textit{console}. Os três mapas apresentaram as saídas esperadas, como estão dispostas na Figura~\ref{fig:problem}.

\begin{table}[H]
\caption{Resultado da verificação por meio ferramenta proposta}
\resizebox{\textwidth}{!}{%
\begin{tabular}{*{14}{|c}|}
\multicolumn{1}{c}{Map 1} & \multicolumn{1}{c}{Map 2} & \multicolumn{1}{c}{Map 3} \\
assert PROGRAM :{[}deadlock free {[}F{]}{]} & assert PROGRAM :{[}deadlock free {[}F{]}{]} & assert PROGRAM :{[}deadlock free {[}F{]}{]} \\
Result: Failed & Result: Failed & Result: Failed \\
Counterexample - Traces: & Counterexample - Traces: & Counterexample - Traces: \\
right() & right() & right() \\
forward(1) & forward(1) & forward(1) \\
forward(1) & forward(1) & forward(1) \\
forward(1) & forward(1) & forward(1) \\
forward(1) & forward(1) & forward(1) \\
forward(1) & forward(1) & forward(1) \\
show(2) & show(2) & show(2) \\
show(3) & show(0) & show(2) \\
show(2) & show(1) & show(3) \\
show(1) & show(2) & show(0) \\
show(3) & show(1) & show(2) \\
show(3) & show(1) & show(1)
\end{tabular}%
}
\fonte{O autor}
\label{table:results}
\end{table}

Diante deste estudo de caso, tendo em vista os resultados obtidos, podemos afirmar que a abordagem de tradução proposta por este trabalho é satisfatória, apesar de algumas limitações. Além disso, vimos a possibilidade de integrar o compilador com o verificador de modelos por meio de uma ferramenta que realiza a verificação de modo transparente ao usuário. Sendo assim, um modo efetivo para auxiliar alunos e professores ao utilizar o ambiente RoboMind.


