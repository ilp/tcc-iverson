\chapter{Conclusão}
\label{chap:cap5}

Uma importante contribuição deste trabalho é a extensão da atual abordagem de verificação automática de programas ROBO para considerar programas com procedimentos e variáveis utilizando as facilidades do \textit{framework} Spoofax. Para isto foi preciso reformular e estender a gramática SDF3 utilizada para fazer o \textit{parsing} de programas ROBO. Foram incluídos na gramática elementos sintáticos para declaração de variáveis, procedimentos, atualização de variáveis e chamada de procedimentos. Em complemento à extensão da gramática, definimos a semântica em CSP dos elementos sintáticos relacionados a variáveis e procedimentos. A semântica foi definida através da inclusão de regras de transformação escritas em Stratego usadas na tradução dos elementos sintáticos adicionados na gramática para os respectivos elementos em CSP. Outra importante contribuição é uma ferramenta com interface gráfica implementada em Java onde o usuário pode selecionar um programa e um conjunto de mapas para verificar se o programa realiza as ações esperadas nos mapas. A ferramenta torna transparente para os usuários o processo de tradução de ROBO para CSP e a verificação do modelo CSP usando FDR. Em acréscimo à interface, as classes da ferramenta podem ser reusadas para implementação de outras ferramentas, umas vez que encapsulam as principais funções de tradução e verificação que são necessárias para implementação de ferramentas de verificação para ROBO. Validamos a abordagem utilizando a ferramenta para verificar o comportamento de um programa ROBO com variáveis e procedimentos. 

%Neste trabalho foram apresentadas a definição da gramática e de regras de tradução para procedimentos e variáveis, estendendo, assim, a abordagem de tradução atual. Utilizamos Spoofax para definição sintática utilizando SDF3 e Stratego para a transformação. Vimos que é preciso uma sistematização durante o processo de tradução automatizando, onde no qual é necessário um conhecimento sobre os diferentes conceitos utilizados. É preciso entender a linguagem ROBO e seus elementos sintáticos, além de propor representações equivalentes em CSP para que se possa utilizar o \textit{framework} para gerar o modelo formal. Validamos essa abordagem utilizando um protótipo com uma interface que oculta para o usuário as ferramentas Spoofax e FDR, de modo que a verificação ocorra automaticamente, e assim, mostrando os resultados ao usuário. O que torna possível o desenvolvimento de aplicações desta finalidade em cenários reais.

%Diante disso, listamos as principais contribuições deste trabalho:
%\begin{itemize}
%    \item Uma abordagem automática para a tradução de programas ROBO para a notação CSP;
%    \item Definição de regras para procedimentos e variáveis;
%    \item Possibilita a criação de ferramentas automáticas que integrem o compilador com o %\end{itemize}

\section{Trabalhos Relacionados}

O único trabalho encontrado na literatura que realiza verificação de programas de robôs educacionais de forma totalmente automática é~\cite{nogueira}. Porém encontramos outro trabalho que usa verificação automática no contexto educacional. O artigo~\cite{SVA} propõe SVA (\textit{Shared Variable Programming}), que é uma ferramenta para o aprendizado de programação concorrente usando uma linguagem educacional; esta ferramenta integra um compilador da linguagem educacional para um modelo CSP com o verificador de modelos FDR. SVA permite analisar propriedades de programas concorrentes como, por exemplo, se os programas entram ao mesmo tempo em uma região crítica. Além disso, a ferramenta possui uma interface gráfica que apresenta os resultados das verificações retornados por FDR de uma forma amigável para o usuário. Esse trabalho mostra que é possível utilizar o FDR e CSP para a criação de ferramentas de verificação automática de linguagens de domínio específico. 

Em \cite{emanuel2017}, é proposto um protótipo de um ambiente para avaliação automática de robôs virtuais. Esse trabalho é uma continuação do trabalho \cite{nogueira} com foco no projeto e prototipação da interface gráfica de um ambiente para avaliação automática de robôs virtuais. O ambiente proposto objetiva a avaliação de forma automática e \textit{feedback} sobre o funcionamento dos programas escritos em ROBO, através de uma interface gráfica que lembra um sistema de julgamento online (\textit{Online Judgment System}) utilizados nas maratonas de programação. A implementação deste ambiente depende diretamente de um dos produtos deste trabalho, que é a extensão do compilador de ROBO para CSP e sua integração com a ferramenta FDR. 

Fora do contexto educacional, existem trabalhos que usam verificação de robôs como os trabalhos~\cite{silva}, \cite{SSS147734} e \cite{araujomotanogueira}.

O trabalho \cite{silva} apresenta um método para a verificação automática durante a simulação de futebol de robôs; o trabalho considera a especificação formal e a verificação de planos de um time de robôs simulados. A simulação ocorre de modo que vários robôs são executados ao mesmo tempo em busca de uma solução conjunta (sistema multiagente). Naquele trabalho é utilizado o verificador de modelos UPPAAL\footnote[9]{http://www.uppaal.org/} para analisar algumas propriedades, dentre elas a verificação da ausência de \textit{deadlock} e \textit{livelock} levando em consideração requisitos de tempo, que é um fator essencial na verificação da simulação de futebol de robôs. Em UPPALL, o modelo do time de robôs é descrito na forma de autômatos temporais (\textit{timed automata}) e as propriedades especificadas na linguagem chamada TCTL (Lógica de Árvore de Cálculo Temporizado). Uma diferença deste trabalho relacionado para o nosso é que a verificação automática em~\cite{silva} é aplicada no domínio de sistemas multiagentes e a notação utilizada na especificação são autômatos temporais. O trabalho que propomos esconde do usuário a representação formal do programa do robô a ser verificado.
%atuam simultaneamente e por isso faz uso de uma outra ferramenta de verificação diferente da FDR.
	
\citeonline{SSS147734} propõe a verificação formal de robôs para assistência pessoal. Esses robôs estão presentes nas casas das pessoas e as ajudam em suas tarefas diárias. Este trabalho usa o popular verificador de modelos SPIN\footnote[10]{http://spinroot.com/spin/whatispin.html} para garantir que os robôs não causem danos às pessoas ou se coloquem em situações inesperadas. 
%Por isso, é proposto um método de verificação formal. 
%O verificador de modelos chamado SPIN que é bastante utilizado em sistemas de missões espaciais, telecomunicação e engenharias. A linguagem desse verificador é chamada PROMELA. Também foi utilizada uma linguagem chamada Brahms para modelar o robô. O processo de verificação ocorre quando o 
O modelo do robô é escrito na notação chamada Brahms\footnote[11]{http://brahms.sourceforge.net/docs/What\%20is\%20BRAHMS.html} (linguagem para modelar processos com multiagentes) que é traduzida para a linguagem PROMELA\footnote[12]{http://spinroot.com/spin/Man/promela.html}. Esta última, é a notação de entrada para o verificador SPIN analisar propriedades do robô, como por exemplo,
%, onde o verificador de modelos pode verificar se as propriedades são satisfeitas ou não. 
se o robô vai se mover para cozinha quando o usuário enviar o pedido para o robô.  
%Essas propriedades são baseadas e pensadas na simulação e validação do usuário final, com o objetivo de aumentar a segurança prática e a confiabilidade dos assistentes robotizados, já que se trata de robôs físicos que estão trabalhando com pessoas reais. 
O processo de verificação em \citeonline{SSS147734} é similar a nossa proposta, uma vez que a linguagem para modelagem do robô é traduzida para uma especificação formal através de um compilador. Uma diferença é que o trabalho relacionado trata de uma simulação voltada para o mundo real, enquanto a proposta deste trabalho é para verificação de robôs virtuais.
%, ainda mais que a DSL (Brahms) possui um propósito totalmente diferente da linguagem ROBO.

O trabalho~\cite{araujomotanogueira} propõe uma abordagem para realizar análises em robôs de limpeza (\textit{cleaning robots}) utilizando Verificação de Modelos Probabilísticos (\textit{Probabilistic Model Checking}) através da linguagem e ferramenta PRISM\footnote[13]{http://www.prismmodelchecker.org/}. Nessa abordagem os algoritmos de movimentação do robô são escritos utilizando uma DSL proposta pelos autores, que é traduzida automaticamente para a notação formal PRISM. A notação formal é utilizada como entrada para a ferramenta PRISM que verifica se o algoritmo satisfaz fórmulas temporais probabilísticas, que medem o consumo energético e o tempo que um robô leva para concluir a tarefa de limpeza em um ambiente predefinido. 
%Ainda mais, \cite{araujomotanogueira} propõe uma DSL para esconder a sintaxe de PRISM com o intuito de facilitar durante a especificação formal para o usuário final. 
Tanto o trabalho~\cite{araujomotanogueira} como o nosso trabalho geram uma especificação formal partir de uma descrição do programa do robô em uma DSL. Entretanto, enquanto a DSL proposta em~\cite{araujomotanogueira} objetiva a especificação de algoritmos de robôs para limpeza, a linguagem ROBO que é o foco do nosso trabalho objetiva a especificação de robôs educacionais. 
%Enquanto o trabalho \cite{araujomotanogueira} foca na verificação de programas específicos, esta pesquisa propõe a verificação automática para diferentes programas, além de realizar a tradução automática dos programas para o modelo formal CSP.

Outro trabalho relacionado é \cite{this-is-boogie-2-2} que propõe Boogie, uma linguagem intermediária desenvolvida para gerar condições e propriedades para a verificação de linguagens de programação de propósito geral, como exemplo, as linguagens C e Spec\#. A proposta em \cite{this-is-boogie-2-2} é traduzir automaticamente o código fonte de programas (ex: na linguagem C) para a linguagem Boogie, que permite a análise automática de propriedades do programa através do verificador (também) chamado Boogie. Enquanto \cite{this-is-boogie-2-2} usa Boogie como linguagem intermediária para representar programa escritos em linguagens de programação de propósito geral, nosso trabalho usa a notação formal de CSP para representar programas escritos na linguagem educativa ROBO. Além disto, as propriedades que podem ser verificadas com Boogie e CSP são diferentes. Enquanto Boogie foca na verificação de invariantes do programa, CSP foca na verificação de refinamentos. 
%; e \cite{Kats} no qual é discutido os desafios e oportunidades de pesquisa para a criação de ambientes de programação com a finalidade de disponibilizá-los na Web, através de um estudo de implementação de uma DSL e um ambiente de programação. Portanto, trabalhos relacionados existem, porém, não são voltados para a verificação automática de robôs educacionais de ambientes voltados para o aprendizado de programação.

Portanto, este trabalho de pesquisa trás várias contribuições para o contexto educacional, uma vez que oferece para estudantes e professores que utilizam ambientes de programação de robôs educacionais um mecanismo de verificação automática para a produção de \textit{feedback} automático sobre a corretude de programas na linguagem ROBO. 
%Além de contribuir também para área da Engenharia de Software através da verificação automática de sistemas educacionais utilizando uma abordagem de tradução automatizada. Portanto, esta proposta oferece grande relevância para a ciência.


\section{Trabalhos Futuros}

A abordagem proposta precisa ser validada com outros exemplos além do exemplo do estudo de caso. Um trabalho futuro consiste em usar outros exemplos para validar a abordagem, além de realizar estudos de caso com potenciais usuários.

Uma das limitações apresentadas é uso da constante \texttt{INTVALUES} com a definição de um limite inferior e superior para as variáveis da especificação formal. No entanto, esses valores poderiam ser definidos com limites específicos para cada variável. Sendo assim, uma importante frente para trabalhos futuros.

Uma das melhorias que pode ser realizada está na criação de regras de tradução que na especificação formal seja proposta uma abordagem que simule uma memória local, dessa forma, mantém apenas as variáveis e parâmetros no escopo de um procedimento. Assim, descartando a adição destes à memória global da especificação, como foi proposto neste trabalho.

Outra melhoria está relacionada com a implementação do compilador para realizar a checagem semântica de ROBO, como por exemplo, checagem de nomes e tipos. Atualmente, a avaliação semântica de ROBO não é realizada pelo compilador, pois espera-se que os programas tenham a semântica validada no ambiente RoboMind antes da tradução para CSP.

Um trabalho futuro consiste em encontrar representações formais mais eficientes. A atual representação em CSP emula a memória como um processo que é colocado em paralelo com os comandos do programa. À medida em que o tamanho do mapa aumenta e o domínio das variáveis, esta forma de modelagem cria uma grande explosão no número de estados do programa durante a análise. A investigação de abordagens mais compactas no número de estados precisam ser estudadas.

Uma limitação da ferramenta desenvolvida é que as propriedades a serem verificadas são escritas como comandos de FDR. Um trabalho futuro é permitir a especificação das propriedades esperadas para o programa através de uma notação amigável que possa ser traduzida automaticamente para CSP; dispensando assim o conhecimento de CSP.
